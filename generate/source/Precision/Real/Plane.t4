	[StructLayout (LayoutKind.Sequential)]
	public struct Plane 
		: IEquatable<Plane>
	{
		public Vector3 Normal;
		public <#= type #> D;

		public Plane (<#= type #> a, <#= type #> b, <#= type #> c, <#= type #> d)
		{
			this.Normal.X = a;
			this.Normal.Y = b;
			this.Normal.Z = c;
			this.D = d;
		}

		public Plane (Vector3 normal, <#= type #> d)
		{
			this.Normal = normal;
			this.D = d;
		}

		public Plane (Vector4 value)
		{
			this.Normal.X = value.X;
			this.Normal.Y = value.Y;
			this.Normal.Z = value.Z;
			this.D = value.W;
		}

		public Plane (Vector3 point1, Vector3 point2, Vector3 point3)
		{
			<#= type #> one = 1;

			<#= type #> num10 = point2.X - point1.X;
			<#= type #> num9 = point2.Y - point1.Y;
			<#= type #> num8 = point2.Z - point1.Z;
			<#= type #> num7 = point3.X - point1.X;
			<#= type #> num6 = point3.Y - point1.Y;
			<#= type #> num5 = point3.Z - point1.Z;
			<#= type #> num4 = (num9 * num5) - (num8 * num6);
			<#= type #> num3 = (num8 * num7) - (num10 * num5);
			<#= type #> num2 = (num10 * num6) - (num9 * num7);
			<#= type #> num11 = ((num4 * num4) + (num3 * num3)) + (num2 * num2);
			<#= type #> num = one / RealMaths.Sqrt (num11);
			this.Normal.X = num4 * num;
			this.Normal.Y = num3 * num;
			this.Normal.Z = num2 * num;
			this.D = -(((this.Normal.X * point1.X) + (this.Normal.Y * point1.Y)) + (this.Normal.Z * point1.Z));
		}

		public Boolean Equals (Plane other)
		{
			return ((((this.Normal.X == other.Normal.X) && (this.Normal.Y == other.Normal.Y)) && (this.Normal.Z == other.Normal.Z)) && (this.D == other.D));
		}

		public override Boolean Equals (Object obj)
		{
			Boolean flag = false;
			if (obj is Plane) {
				flag = this.Equals ((Plane)obj);
			}
			return flag;
		}

		public override Int32 GetHashCode ()
		{
			return (this.Normal.GetHashCode () + this.D.GetHashCode ());
		}

		public override String ToString ()
		{
			return string.Format ("{{Normal:{0} D:{1}}}", new Object[] { this.Normal.ToString (), this.D.ToString () });
		}

		public void Normalise ()
		{
			<#= type #> one = 1;
			<#= type #> somethingWicked; RealMaths.FromString("0.0000001192093", out somethingWicked);

			<#= type #> num2 = ((this.Normal.X * this.Normal.X) + (this.Normal.Y * this.Normal.Y)) + (this.Normal.Z * this.Normal.Z);
			if (RealMaths.Abs (num2 - one) >= somethingWicked) {
				<#= type #> num = one / RealMaths.Sqrt (num2);
				this.Normal.X *= num;
				this.Normal.Y *= num;
				this.Normal.Z *= num;
				this.D *= num;
			}
		}

		public static void Normalise (ref Plane value, out Plane result)
		{
			<#= type #> one = 1;
			<#= type #> somethingWicked; RealMaths.FromString("0.0000001192093", out somethingWicked);

			<#= type #> num2 = ((value.Normal.X * value.Normal.X) + (value.Normal.Y * value.Normal.Y)) + (value.Normal.Z * value.Normal.Z);
			if (RealMaths.Abs (num2 - one) < somethingWicked) {
				result.Normal = value.Normal;
				result.D = value.D;
			} else {
				<#= type #> num = one / RealMaths.Sqrt (num2);
				result.Normal.X = value.Normal.X * num;
				result.Normal.Y = value.Normal.Y * num;
				result.Normal.Z = value.Normal.Z * num;
				result.D = value.D * num;
			}
		}

		public static void Transform (ref Plane plane, ref Matrix44 matrix, out Plane result)
		{
			Matrix44 matrix2;
			Matrix44.Invert (ref matrix, out matrix2);
			<#= type #> x = plane.Normal.X;
			<#= type #> y = plane.Normal.Y;
			<#= type #> z = plane.Normal.Z;
			<#= type #> d = plane.D;
			result.Normal.X = (((x * matrix2.M11) + (y * matrix2.M12)) + (z * matrix2.M13)) + (d * matrix2.M14);
			result.Normal.Y = (((x * matrix2.M21) + (y * matrix2.M22)) + (z * matrix2.M23)) + (d * matrix2.M24);
			result.Normal.Z = (((x * matrix2.M31) + (y * matrix2.M32)) + (z * matrix2.M33)) + (d * matrix2.M34);
			result.D = (((x * matrix2.M41) + (y * matrix2.M42)) + (z * matrix2.M43)) + (d * matrix2.M44);
		}


		public static void Transform (ref Plane plane, ref Quaternion rotation, out Plane result)
		{
			<#= type #> one = 1;

			<#= type #> num15 = rotation.X + rotation.X;
			<#= type #> num5 = rotation.Y + rotation.Y;
			<#= type #> num = rotation.Z + rotation.Z;
			<#= type #> num14 = rotation.W * num15;
			<#= type #> num13 = rotation.W * num5;
			<#= type #> num12 = rotation.W * num;
			<#= type #> num11 = rotation.X * num15;
			<#= type #> num10 = rotation.X * num5;
			<#= type #> num9 = rotation.X * num;
			<#= type #> num8 = rotation.Y * num5;
			<#= type #> num7 = rotation.Y * num;
			<#= type #> num6 = rotation.Z * num;
			<#= type #> num24 = (one - num8) - num6;
			<#= type #> num23 = num10 - num12;
			<#= type #> num22 = num9 + num13;
			<#= type #> num21 = num10 + num12;
			<#= type #> num20 = (one - num11) - num6;
			<#= type #> num19 = num7 - num14;
			<#= type #> num18 = num9 - num13;
			<#= type #> num17 = num7 + num14;
			<#= type #> num16 = (one - num11) - num8;
			<#= type #> x = plane.Normal.X;
			<#= type #> y = plane.Normal.Y;
			<#= type #> z = plane.Normal.Z;
			result.Normal.X = ((x * num24) + (y * num23)) + (z * num22);
			result.Normal.Y = ((x * num21) + (y * num20)) + (z * num19);
			result.Normal.Z = ((x * num18) + (y * num17)) + (z * num16);
			result.D = plane.D;
		}
		


		public <#= type #> Dot(ref Vector4 value)
		{
			return (((this.Normal.X * value.X) + (this.Normal.Y * value.Y)) + (this.Normal.Z * value.Z)) + (this.D * value.W);
		}

		public <#= type #> DotCoordinate (ref Vector3 value)
		{
			return (((this.Normal.X * value.X) + (this.Normal.Y * value.Y)) + (this.Normal.Z * value.Z)) + this.D;
		}

		public <#= type #> DotNormal (ref Vector3 value)
		{
			return ((this.Normal.X * value.X) + (this.Normal.Y * value.Y)) + (this.Normal.Z * value.Z);
		}

		public PlaneIntersectionType Intersects (ref BoundingBox box)
		{
			<#= type #> zero = 0;

			Vector3 vector;
			Vector3 vector2;
			vector2.X = (this.Normal.X >= zero) ? box.Min.X : box.Max.X;
			vector2.Y = (this.Normal.Y >= zero) ? box.Min.Y : box.Max.Y;
			vector2.Z = (this.Normal.Z >= zero) ? box.Min.Z : box.Max.Z;
			vector.X = (this.Normal.X >= zero) ? box.Max.X : box.Min.X;
			vector.Y = (this.Normal.Y >= zero) ? box.Max.Y : box.Min.Y;
			vector.Z = (this.Normal.Z >= zero) ? box.Max.Z : box.Min.Z;
			<#= type #> num = ((this.Normal.X * vector2.X) + (this.Normal.Y * vector2.Y)) + (this.Normal.Z * vector2.Z);
			if ((num + this.D) > zero) {
				return PlaneIntersectionType.Front;
			} else {
				num = ((this.Normal.X * vector.X) + (this.Normal.Y * vector.Y)) + (this.Normal.Z * vector.Z);
				if ((num + this.D) < zero) {
					return PlaneIntersectionType.Back;
				} else {
					return PlaneIntersectionType.Intersecting;
				}
			}
		}

		public PlaneIntersectionType Intersects (ref BoundingFrustum frustum)
		{
			if (null == frustum) {
				throw new ArgumentNullException ("frustum - NullNotAllowed");
			}
			return frustum.Intersects (ref this);
		}

		public PlaneIntersectionType Intersects (ref BoundingSphere sphere)
		{
			<#= type #> num2 = ((sphere.Center.X * this.Normal.X) + (sphere.Center.Y * this.Normal.Y)) + (sphere.Center.Z * this.Normal.Z);
			<#= type #> num = num2 + this.D;
			if (num > sphere.Radius) {
				return PlaneIntersectionType.Front;
			} else if (num < -sphere.Radius) {
				return PlaneIntersectionType.Back;
			} else {
				return PlaneIntersectionType.Intersecting;
			}
		}

		public static Boolean operator == (Plane lhs, Plane rhs)
		{
			return lhs.Equals (rhs);
		}

		public static Boolean operator != (Plane lhs, Plane rhs)
		{
			if (((lhs.Normal.X == rhs.Normal.X) && (lhs.Normal.Y == rhs.Normal.Y)) && (lhs.Normal.Z == rhs.Normal.Z)) {
				return !(lhs.D == rhs.D);
			}
			return true;
		}
	}
