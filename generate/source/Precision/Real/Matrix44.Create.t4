		#region Create

		public static void CreateTranslation (ref Vector3 position, out Matrix44 result)
		{
			result.M11 = 1;
			result.M12 = 0;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = 1;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = 0;
			result.M33 = 1;
			result.M34 = 0;
			result.M41 = position.X;
			result.M42 = position.Y;
			result.M43 = position.Z;
			result.M44 = 1;
		}
		
		public static void CreateTranslation (<#= type #> xPosition, <#= type #> yPosition, <#= type #> zPosition, out Matrix44 result)
		{	
			result.M11 = 1;
			result.M12 = 0;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = 1;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = 0;
			result.M33 = 1;
			result.M34 = 0;
			result.M41 = xPosition;
			result.M42 = yPosition;
			result.M43 = zPosition;
			result.M44 = 1;
		}
		
		// Creates a scaling matrix based on x, y, z.
		public static void CreateScale (<#= type #> xScale, <#= type #> yScale, <#= type #> zScale, out Matrix44 result)
		{
			result.M11 = xScale;
			result.M12 = 0;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = yScale;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = 0;
			result.M33 = zScale;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}

		// Creates a scaling matrix based on a vector.
		public static void CreateScale (ref Vector3 scales, out Matrix44 result)
		{
			result.M11 = scales.X;
			result.M12 = 0;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = scales.Y;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = 0;
			result.M33 = scales.Z;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}

		// Create a scaling matrix consistant along each axis
		public static void CreateScale (<#= type #> scale, out Matrix44 result)
		{
			result.M11 = scale;
			result.M12 = 0;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = scale;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = 0;
			result.M33 = scale;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}

		public static void CreateRotationX (<#= type #> radians, out Matrix44 result)
		{
			// http://en.wikipedia.org/wiki/Rotation_matrix

			<#= type #> cos = RealMaths.Cos (radians);
			<#= type #> sin = RealMaths.Sin (radians);

			result.M11 = 1;
			result.M12 = 0;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = cos;
			result.M23 = sin;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = -sin;
			result.M33 = cos;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}

		public static void CreateRotationY (<#= type #> radians, out Matrix44 result)
		{
			// http://en.wikipedia.org/wiki/Rotation_matrix

			<#= type #> cos = RealMaths.Cos (radians);
			<#= type #> sin = RealMaths.Sin (radians);

			result.M11 = cos;
			result.M12 = 0;
			result.M13 = -sin;
			result.M14 = 0;
			result.M21 = 0;
			result.M22 = 1;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = sin;
			result.M32 = 0;
			result.M33 = cos;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}
		
		public static void CreateRotationZ (<#= type #> radians, out Matrix44 result)
		{
			// http://en.wikipedia.org/wiki/Rotation_matrix

			<#= type #> cos = RealMaths.Cos (radians);
			<#= type #> sin = RealMaths.Sin (radians);

			result.M11 = cos;
			result.M12 = sin;
			result.M13 = 0;
			result.M14 = 0;
			result.M21 = -sin;
			result.M22 = cos;
			result.M23 = 0;
			result.M24 = 0;
			result.M31 = 0;
			result.M32 = 0;
			result.M33 = 1;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}
		
		public static void CreateFromAxisAngle (ref Vector3 axis, <#= type #> angle, out Matrix44 result)
		{
			<#= type #> one = 1;

			<#= type #> x = axis.X;
			<#= type #> y = axis.Y;
			<#= type #> z = axis.Z;

			<#= type #> sin = RealMaths.Sin (angle);
			<#= type #> cos = RealMaths.Cos (angle);

			<#= type #> xx = x * x;
			<#= type #> yy = y * y;
			<#= type #> zz = z * z;

			<#= type #> xy = x * y;
			<#= type #> xz = x * z;
			<#= type #> yz = y * z;

			result.M11 = xx + (cos * (one - xx));
			result.M12 = (xy - (cos * xy)) + (sin * z);
			result.M13 = (xz - (cos * xz)) - (sin * y);
			result.M14 = 0;

			result.M21 = (xy - (cos * xy)) - (sin * z);
			result.M22 = yy + (cos * (one - yy));
			result.M23 = (yz - (cos * yz)) + (sin * x);
			result.M24 = 0;

			result.M31 = (xz - (cos * xz)) + (sin * y);
			result.M32 = (yz - (cos * yz)) - (sin * x);
			result.M33 = zz + (cos * (one - zz));
			result.M34 = 0;

			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = one;
		}
		
		public static void CreateFromAllAxis (ref Vector3 right, ref Vector3 up, ref Vector3 backward, out Matrix44 result)
		{
			if(!right.IsUnit() || !up.IsUnit() || !backward.IsUnit() )
			{
				throw new ArgumentException("The input vertors must be normalised.");
			}

			result.M11 = right.X;
			result.M12 = right.Y;
			result.M13 = right.Z;
			result.M14 = 0;
			result.M21 = up.X;
			result.M22 = up.Y;
			result.M23 = up.Z;
			result.M24 = 0;
			result.M31 = backward.X;
			result.M32 = backward.Y;
			result.M33 = backward.Z;
			result.M34 = 0;
			result.M41 = 0;
			result.M42 = 0;
			result.M43 = 0;
			result.M44 = 1;
		}

		public static void CreateWorldNew (ref Vector3 position, ref Vector3 forward, ref Vector3 up, out Matrix44 result)
		{
			Vector3 backward = -forward;

			Vector3 right;

			Vector3.Cross (ref up, ref backward, out right);

			right.Normalise();

			Matrix44.CreateFromAllAxis(ref right, ref up, ref backward, out result);

			result.M41 = position.X;
			result.M42 = position.Y;
			result.M43 = position.Z;
		}

		public static void CreateWorld (ref Vector3 position, ref Vector3 forward, ref Vector3 up, out Matrix44 result)
		{
			if(!forward.IsUnit() || !up.IsUnit() )
			{
				throw new ArgumentException("The input vertors must be normalised.");
			}

			Vector3 backward = -forward;

			Vector3 vector; Vector3.Normalise (ref backward, out vector);

			Vector3 cross; Vector3.Cross (ref up, ref vector, out cross);

			Vector3 vector2; Vector3.Normalise (ref cross, out vector2);

			Vector3 vector3; Vector3.Cross (ref vector, ref vector2, out vector3);

			result.M11 = vector2.X;
			result.M12 = vector2.Y;
			result.M13 = vector2.Z;
			result.M14 = 0;
			result.M21 = vector3.X;
			result.M22 = vector3.Y;
			result.M23 = vector3.Z;
			result.M24 = 0;
			result.M31 = vector.X;
			result.M32 = vector.Y;
			result.M33 = vector.Z;
			result.M34 = 0;
			result.M41 = position.X;
			result.M42 = position.Y;
			result.M43 = position.Z;
			result.M44 = 1;
		}

		public static void CreateFromQuaternion (ref Quaternion quaternion, out Matrix44 result)
		{
			if(!quaternion.IsUnit())
			{
				throw new ArgumentException("Input quaternion must be normalised.");
			}

			<#= type #> zero = 0;
			<#= type #> one = 1;

			<#= type #> xs = quaternion.X + quaternion.X;   
			<#= type #> ys = quaternion.Y + quaternion.Y;
			<#= type #> zs = quaternion.Z + quaternion.Z;
			<#= type #> wx = quaternion.W * xs;
			<#= type #> wy = quaternion.W * ys;
			<#= type #> wz = quaternion.W * zs;
			<#= type #> xx = quaternion.X * xs;
			<#= type #> xy = quaternion.X * ys;
			<#= type #> xz = quaternion.X * zs;
			<#= type #> yy = quaternion.Y * ys;
			<#= type #> yz = quaternion.Y * zs;
			<#= type #> zz = quaternion.Z * zs;

			result.M11 = one - (yy + zz);
			result.M21 = xy - wz;
			result.M31 = xz + wy;
			result.M41 = zero;
    
			result.M12 = xy + wz;
			result.M22 = one - (xx + zz);
			result.M32 = yz - wx;
			result.M42 = zero;
    
			result.M13 = xz - wy;
			result.M23 = yz + wx;
			result.M33 = one - (xx + yy);
			result.M43 = zero;

			result.M14 = zero;
			result.M24 = zero;
			result.M34 = zero;
			result.M44 = one;
		}



		// todo: remove when we dont need this for the tests
		internal static void CreateFromQuaternionOld (ref Quaternion quaternion, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);
			<#= type #> two = 2;

			<#= type #> num9 = quaternion.X * quaternion.X;
			<#= type #> num8 = quaternion.Y * quaternion.Y;
			<#= type #> num7 = quaternion.Z * quaternion.Z;
			<#= type #> num6 = quaternion.X * quaternion.Y;
			<#= type #> num5 = quaternion.Z * quaternion.W;
			<#= type #> num4 = quaternion.Z * quaternion.X;
			<#= type #> num3 = quaternion.Y * quaternion.W;
			<#= type #> num2 = quaternion.Y * quaternion.Z;
			<#= type #> num = quaternion.X * quaternion.W;
			result.M11 = one - (two * (num8 + num7));
			result.M12 = two * (num6 + num5);
			result.M13 = two * (num4 - num3);
			result.M14 = zero;
			result.M21 = two * (num6 - num5);
			result.M22 = one - (two * (num7 + num9));
			result.M23 = two * (num2 + num);
			result.M24 = zero;
			result.M31 = two * (num4 + num3);
			result.M32 = two * (num2 - num);
			result.M33 = one - (two * (num8 + num9));
			result.M34 = zero;
			result.M41 = zero;
			result.M42 = zero;
			result.M43 = zero;
			result.M44 = one;
		}

		public static void CreateFromYawPitchRoll (<#= type #> yaw, <#= type #> pitch, <#= type #> roll, out Matrix44 result)
		{
			Quaternion quaternion;

			Quaternion.CreateFromYawPitchRoll (yaw, pitch, roll, out quaternion);

			CreateFromQuaternion (ref quaternion, out result);
		}










		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////
		// TODO: REVIEW FROM HERE ONWARDS
		/////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////


		// FROM XNA
		// --------
		// Creates a cylindrical billboard that rotates around a specified axis.
		// This method computes the facing direction of the billboard from the object position and camera position. 
		// When the object and camera positions are too close, the matrix will not be accurate. 
		// To avoid this problem, the method uses the optional camera forward vector if the positions are too close.
		public static void CreateBillboard (ref Vector3 ObjectPosition, ref Vector3 cameraPosition, ref Vector3 cameraUpVector, Vector3? cameraForwardVector, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);

			Vector3 vector;
			Vector3 vector2;
			Vector3 vector3;
			vector.X = ObjectPosition.X - cameraPosition.X;
			vector.Y = ObjectPosition.Y - cameraPosition.Y;
			vector.Z = ObjectPosition.Z - cameraPosition.Z;
			<#= type #> num = vector.LengthSquared ();
			<#= type #> limit; RealMaths.FromString("0.0001", out limit);

			if (num < limit) {
				vector = cameraForwardVector.HasValue ? -cameraForwardVector.Value : Vector3.Forward;
			} else {
				Vector3.Multiply (ref vector, (<#= type #>)(one / (RealMaths.Sqrt (num))), out vector);
			}
			Vector3.Cross (ref cameraUpVector, ref vector, out vector3);
			vector3.Normalise ();
			Vector3.Cross (ref vector, ref vector3, out vector2);
			result.M11 = vector3.X;
			result.M12 = vector3.Y;
			result.M13 = vector3.Z;
			result.M14 = zero;
			result.M21 = vector2.X;
			result.M22 = vector2.Y;
			result.M23 = vector2.Z;
			result.M24 = zero;
			result.M31 = vector.X;
			result.M32 = vector.Y;
			result.M33 = vector.Z;
			result.M34 = zero;
			result.M41 = ObjectPosition.X;
			result.M42 = ObjectPosition.Y;
			result.M43 = ObjectPosition.Z;
			result.M44 = one;
		}
		
		public static void CreateConstrainedBillboard (ref Vector3 objectPosition, ref Vector3 cameraPosition, ref Vector3 rotateAxis, Vector3? cameraForwardVector, Vector3? objectForwardVector, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);

			<#= type #> num;
			Vector3 vector;
			Vector3 vector2;
			Vector3 vector3;
			vector2.X = objectPosition.X - cameraPosition.X;
			vector2.Y = objectPosition.Y - cameraPosition.Y;
			vector2.Z = objectPosition.Z - cameraPosition.Z;
			<#= type #> num2 = vector2.LengthSquared ();
			<#= type #> limit; RealMaths.FromString("0.0001", out limit);

			if (num2 < limit) {
				vector2 = cameraForwardVector.HasValue ? -cameraForwardVector.Value : Vector3.Forward;
			} else {
				Vector3.Multiply (ref vector2, (<#= type #>)(one / (RealMaths.Sqrt (num2))), out vector2);
			}
			Vector3 vector4 = rotateAxis;
			Vector3.Dot (ref rotateAxis, ref vector2, out num);

			<#= type #> realHorrid; RealMaths.FromString("0.9982547", out realHorrid);

			if (RealMaths.Abs (num) > realHorrid) {
				if (objectForwardVector.HasValue) {
					vector = objectForwardVector.Value;
					Vector3.Dot (ref rotateAxis, ref vector, out num);
					if (RealMaths.Abs (num) > realHorrid) {
						num = ((rotateAxis.X * Vector3.Forward.X) + (rotateAxis.Y * Vector3.Forward.Y)) + (rotateAxis.Z * Vector3.Forward.Z);
						vector = (RealMaths.Abs (num) > realHorrid) ? Vector3.Right : Vector3.Forward;
					}
				} else {
					num = ((rotateAxis.X * Vector3.Forward.X) + (rotateAxis.Y * Vector3.Forward.Y)) + (rotateAxis.Z * Vector3.Forward.Z);
					vector = (RealMaths.Abs (num) > realHorrid) ? Vector3.Right : Vector3.Forward;
				}
				Vector3.Cross (ref rotateAxis, ref vector, out vector3);
				vector3.Normalise ();
				Vector3.Cross (ref vector3, ref rotateAxis, out vector);
				vector.Normalise ();
			} else {
				Vector3.Cross (ref rotateAxis, ref vector2, out vector3);
				vector3.Normalise ();
				Vector3.Cross (ref vector3, ref vector4, out vector);
				vector.Normalise ();
			}
			result.M11 = vector3.X;
			result.M12 = vector3.Y;
			result.M13 = vector3.Z;
			result.M14 = zero;
			result.M21 = vector4.X;
			result.M22 = vector4.Y;
			result.M23 = vector4.Z;
			result.M24 = zero;
			result.M31 = vector.X;
			result.M32 = vector.Y;
			result.M33 = vector.Z;
			result.M34 = zero;
			result.M41 = objectPosition.X;
			result.M42 = objectPosition.Y;
			result.M43 = objectPosition.Z;
			result.M44 = one;
		}

		// ref: http://msdn.microsoft.com/en-us/library/bb205351(v=vs.85).aspx
		public static void CreatePerspectiveFieldOfView (<#= type #> fieldOfView, <#= type #> aspectRatio, <#= type #> nearPlaneDistance, <#= type #> farPlaneDistance, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> half; RealMaths.Half(out half);
			<#= type #> one; RealMaths.One(out one);
			<#= type #> pi; RealMaths.Pi(out pi);

			if ((fieldOfView <= zero) || (fieldOfView >= pi)) {
				throw new ArgumentOutOfRangeException ("fieldOfView");
			}
			if (nearPlaneDistance <= zero) {
				throw new ArgumentOutOfRangeException ("nearPlaneDistance");
			}
			if (farPlaneDistance <= zero) {
				throw new ArgumentOutOfRangeException ("farPlaneDistance");
			}
			if (nearPlaneDistance >= farPlaneDistance) {
				throw new ArgumentOutOfRangeException ("nearPlaneDistance");
			}
			<#= type #> num = one / (RealMaths.Tan ((fieldOfView * half)));
			<#= type #> num9 = num / aspectRatio;
			result.M11 = num9;
			result.M12 = result.M13 = result.M14 = zero;
			result.M22 = num;
			result.M21 = result.M23 = result.M24 = zero;
			result.M31 = result.M32 = zero;
			result.M33 = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M34 = -one;
			result.M41 = result.M42 = result.M44 = zero;
			result.M43 = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
		}

		// ref: http://msdn.microsoft.com/en-us/library/bb205355(v=vs.85).aspx
		public static void CreatePerspective (<#= type #> width, <#= type #> height, <#= type #> nearPlaneDistance, <#= type #> farPlaneDistance, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);
			<#= type #> two = 2;

			if (nearPlaneDistance <= zero) {
				throw new ArgumentOutOfRangeException ("nearPlaneDistance");
			}
			if (farPlaneDistance <= zero) {
				throw new ArgumentOutOfRangeException ("farPlaneDistance");
			}
			if (nearPlaneDistance >= farPlaneDistance) {
				throw new ArgumentOutOfRangeException ("nearPlaneDistance");
			}
			result.M11 = (two * nearPlaneDistance) / width;
			result.M12 = result.M13 = result.M14 = zero;
			result.M22 = (two * nearPlaneDistance) / height;
			result.M21 = result.M23 = result.M24 = zero;
			result.M33 = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M31 = result.M32 = zero;
			result.M34 = -one;
			result.M41 = result.M42 = result.M44 = zero;
			result.M43 = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
		}


		// ref: http://msdn.microsoft.com/en-us/library/bb205354(v=vs.85).aspx
		public static void CreatePerspectiveOffCenter (<#= type #> left, <#= type #> right, <#= type #> bottom, <#= type #> top, <#= type #> nearPlaneDistance, <#= type #> farPlaneDistance, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);
			<#= type #> two = 2;

			if (nearPlaneDistance <= zero) {
				throw new ArgumentOutOfRangeException ("nearPlaneDistance");
			}
			if (farPlaneDistance <= zero) {
				throw new ArgumentOutOfRangeException ("farPlaneDistance");
			}
			if (nearPlaneDistance >= farPlaneDistance) {
				throw new ArgumentOutOfRangeException ("nearPlaneDistance");
			}
			result.M11 = (two * nearPlaneDistance) / (right - left);
			result.M12 = result.M13 = result.M14 = zero;
			result.M22 = (two * nearPlaneDistance) / (top - bottom);
			result.M21 = result.M23 = result.M24 = zero;
			result.M31 = (left + right) / (right - left);
			result.M32 = (top + bottom) / (top - bottom);
			result.M33 = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
			result.M34 = -one;
			result.M43 = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
			result.M41 = result.M42 = result.M44 = zero;
		}
		
		// ref: http://msdn.microsoft.com/en-us/library/bb205349(v=vs.85).aspx
		public static void CreateOrthographic (<#= type #> width, <#= type #> height, <#= type #> zNearPlane, <#= type #> zFarPlane, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);
			<#= type #> two = 2;

			result.M11 = two / width;
			result.M12 = result.M13 = result.M14 = zero;
			result.M22 = two / height;
			result.M21 = result.M23 = result.M24 = zero;
			result.M33 = one / (zNearPlane - zFarPlane);
			result.M31 = result.M32 = result.M34 = zero;
			result.M41 = result.M42 = zero;
			result.M43 = zNearPlane / (zNearPlane - zFarPlane);
			result.M44 = one;
		}

		// ref: http://msdn.microsoft.com/en-us/library/bb205348(v=vs.85).aspx
		public static void CreateOrthographicOffCenter (<#= type #> left, <#= type #> right, <#= type #> bottom, <#= type #> top, <#= type #> zNearPlane, <#= type #> zFarPlane, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);
			<#= type #> two = 2;

			result.M11 = two / (right - left);
			result.M12 = result.M13 = result.M14 = zero;
			result.M22 = two / (top - bottom);
			result.M21 = result.M23 = result.M24 = zero;
			result.M33 = one / (zNearPlane - zFarPlane);
			result.M31 = result.M32 = result.M34 = zero;
			result.M41 = (left + right) / (left - right);
			result.M42 = (top + bottom) / (bottom - top);
			result.M43 = zNearPlane / (zNearPlane - zFarPlane);
			result.M44 = one;
		}
		
		// ref: http://msdn.microsoft.com/en-us/library/bb205343(v=VS.85).aspx
		public static void CreateLookAt (ref Vector3 cameraPosition, ref Vector3 cameraTarget, ref Vector3 cameraUpVector, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);

			Vector3 targetToPosition = cameraPosition - cameraTarget;

			Vector3 vector; Vector3.Normalise (ref targetToPosition, out vector);

			Vector3 cross; Vector3.Cross (ref cameraUpVector, ref vector, out cross); 

			Vector3 vector2; Vector3.Normalise (ref cross, out vector2);
			Vector3 vector3; Vector3.Cross (ref vector, ref vector2, out vector3);
			result.M11 = vector2.X;
			result.M12 = vector3.X;
			result.M13 = vector.X;
			result.M14 = zero;
			result.M21 = vector2.Y;
			result.M22 = vector3.Y;
			result.M23 = vector.Y;
			result.M24 = zero;
			result.M31 = vector2.Z;
			result.M32 = vector3.Z;
			result.M33 = vector.Z;
			result.M34 = zero;

			Vector3.Dot (ref vector2, ref cameraPosition, out result.M41);
			Vector3.Dot (ref vector3, ref cameraPosition, out result.M42);
			Vector3.Dot (ref vector, ref cameraPosition, out result.M43);
			
			result.M41 *= -one;
			result.M42 *= -one;
			result.M43 *= -one;

			result.M44 = one;
		}

		
	

		// ref: http://msdn.microsoft.com/en-us/library/bb205364(v=VS.85).aspx
		public static void CreateShadow (ref Vector3 lightDirection, ref Plane plane, out Matrix44 result)
		{
			<#= type #> zero = 0;
			
			Plane plane2;
			Plane.Normalise (ref plane, out plane2);
			<#= type #> num = ((plane2.Normal.X * lightDirection.X) + (plane2.Normal.Y * lightDirection.Y)) + (plane2.Normal.Z * lightDirection.Z);
			<#= type #> num5 = -plane2.Normal.X;
			<#= type #> num4 = -plane2.Normal.Y;
			<#= type #> num3 = -plane2.Normal.Z;
			<#= type #> num2 = -plane2.D;
			result.M11 = (num5 * lightDirection.X) + num;
			result.M21 = num4 * lightDirection.X;
			result.M31 = num3 * lightDirection.X;
			result.M41 = num2 * lightDirection.X;
			result.M12 = num5 * lightDirection.Y;
			result.M22 = (num4 * lightDirection.Y) + num;
			result.M32 = num3 * lightDirection.Y;
			result.M42 = num2 * lightDirection.Y;
			result.M13 = num5 * lightDirection.Z;
			result.M23 = num4 * lightDirection.Z;
			result.M33 = (num3 * lightDirection.Z) + num;
			result.M43 = num2 * lightDirection.Z;
			result.M14 = zero;
			result.M24 = zero;
			result.M34 = zero;
			result.M44 = num;
		}

		// ref: http://msdn.microsoft.com/en-us/library/bb205356(v=VS.85).aspx
		public static void CreateReflection (ref Plane value, out Matrix44 result)
		{
			<#= type #> zero = 0;
			<#= type #> one; RealMaths.One(out one);
			<#= type #> two = 2;

			Plane plane;
			
			Plane.Normalise (ref value, out plane);
			
			value.Normalise ();
			
			<#= type #> x = plane.Normal.X;
			<#= type #> y = plane.Normal.Y;
			<#= type #> z = plane.Normal.Z;
			
			<#= type #> num3 = -two * x;
			<#= type #> num2 = -two * y;
			<#= type #> num = -two * z;
			
			result.M11 = (num3 * x) + one;
			result.M12 = num2 * x;
			result.M13 = num * x;
			result.M14 = zero;
			result.M21 = num3 * y;
			result.M22 = (num2 * y) + one;
			result.M23 = num * y;
			result.M24 = zero;
			result.M31 = num3 * z;
			result.M32 = num2 * z;
			result.M33 = (num * z) + one;
			result.M34 = zero;
			result.M41 = num3 * plane.D;
			result.M42 = num2 * plane.D;
			result.M43 = num * plane.D;
			result.M44 = one;
		}
		
		#endregion
