	[StructLayout (LayoutKind.Sequential)]
	public struct BoundingSphere 
		: IEquatable<BoundingSphere>
	{
		public Vector3 Center;
		public <#= type #> Radius;

		public BoundingSphere (Vector3 center, <#= type #> radius)
		{
			<#= type #> zero = 0;

			if (radius < zero) {
				throw new ArgumentException ("NegativeRadius");
			}
			this.Center = center;
			this.Radius = radius;
		}

		public Boolean Equals (BoundingSphere other)
		{
			return ((this.Center == other.Center) && (this.Radius == other.Radius));
		}

		public override Boolean Equals (Object obj)
		{
			Boolean flag = false;
			if (obj is BoundingSphere) {
				flag = this.Equals ((BoundingSphere)obj);
			}
			return flag;
		}

		public override Int32 GetHashCode ()
		{
			return (this.Center.GetHashCode () + this.Radius.GetHashCode ());
		}

		public override String ToString ()
		{
			return string.Format ("{{Center:{0} Radius:{1}}}", new Object[] { this.Center.ToString (), this.Radius.ToString () });
		}

		public static void CreateMerged (ref BoundingSphere original, ref BoundingSphere additional, out BoundingSphere result)
		{
			<#= type #> half; RealMaths.Half(out half);
			<#= type #> one = 1;
			Vector3 vector2;
			Vector3.Subtract (ref additional.Center, ref original.Center, out vector2);
			<#= type #> num = vector2.Length ();
			<#= type #> radius = original.Radius;
			<#= type #> num2 = additional.Radius;
			if ((radius + num2) >= num) {
				if ((radius - num2) >= num) {
					result = original;
					return;
				}
				if ((num2 - radius) >= num) {
					result = additional;
					return;
				}
			}
			Vector3 vector = (Vector3)(vector2 * (one / num));
			<#= type #> num5 = RealMaths.Min (-radius, num - num2);
			<#= type #> num4 = (RealMaths.Max (radius, num + num2) - num5) * half;
			result.Center = original.Center + ((Vector3)(vector * (num4 + num5)));
			result.Radius = num4;
		}

		public static void CreateFromBoundingBox (ref BoundingBox box, out BoundingSphere result)
		{
			<#= type #> half; RealMaths.Half(out half);
			<#= type #> num;
			Vector3.Lerp (ref box.Min, ref box.Max, half, out result.Center);
			Vector3.Distance (ref box.Min, ref box.Max, out num);
			result.Radius = num * half;
		}

		public static void CreateFromPoints (IEnumerable<Vector3> points, out BoundingSphere sphere)
		{	
			<#= type #> half; RealMaths.Half(out half);
			<#= type #> one = 1;

			<#= type #> num;
			<#= type #> num2;
			Vector3 vector2;
			<#= type #> num4;
			<#= type #> num5;
			
			Vector3 vector5;
			Vector3 vector6;
			Vector3 vector7;
			Vector3 vector8;
			Vector3 vector9;
			if (points == null) {
				throw new ArgumentNullException ("points");
			}
			IEnumerator<Vector3> enumerator = points.GetEnumerator ();
			if (!enumerator.MoveNext ()) {
				throw new ArgumentException ("BoundingSphereZeroPoints");
			}
			Vector3 vector4 = vector5 = vector6 = vector7 = vector8 = vector9 = enumerator.Current;
			foreach (Vector3 vector in points) {
				if (vector.X < vector4.X) {
					vector4 = vector;
				}
				if (vector.X > vector5.X) {
					vector5 = vector;
				}
				if (vector.Y < vector6.Y) {
					vector6 = vector;
				}
				if (vector.Y > vector7.Y) {
					vector7 = vector;
				}
				if (vector.Z < vector8.Z) {
					vector8 = vector;
				}
				if (vector.Z > vector9.Z) {
					vector9 = vector;
				}
			}
			Vector3.Distance (ref vector5, ref vector4, out num5);
			Vector3.Distance (ref vector7, ref vector6, out num4);
			Vector3.Distance (ref vector9, ref vector8, out num2);
			if (num5 > num4) {
				if (num5 > num2) {
					Vector3.Lerp (ref vector5, ref vector4, half, out vector2);
					num = num5 * half;
				} else {
					Vector3.Lerp (ref vector9, ref vector8, half, out vector2);
					num = num2 * half;
				}
			} else if (num4 > num2) {
				Vector3.Lerp (ref vector7, ref vector6, half, out vector2);
				num = num4 * half;
			} else {
				Vector3.Lerp (ref vector9, ref vector8, half, out vector2);
				num = num2 * half;
			}
			foreach (Vector3 vector10 in points) {
				Vector3 vector3;
				vector3.X = vector10.X - vector2.X;
				vector3.Y = vector10.Y - vector2.Y;
				vector3.Z = vector10.Z - vector2.Z;
				<#= type #> num3 = vector3.Length ();
				if (num3 > num) {
					num = (num + num3) * half;
					vector2 += (Vector3)((one - (num / num3)) * vector3);
				}
			}
			sphere.Center = vector2;
			sphere.Radius = num;
		}

		public static void CreateFromFrustum (ref BoundingFrustum frustum, out BoundingSphere sphere)
		{
			if (frustum == null) {
				throw new ArgumentNullException ("frustum");
			}

			CreateFromPoints (frustum.cornerArray, out sphere);
		}

		public Boolean Intersects (ref BoundingBox box)
		{
			<#= type #> num;
			Vector3 vector;
			Vector3.Clamp (ref this.Center, ref box.Min, ref box.Max, out vector);
			Vector3.DistanceSquared (ref this.Center, ref vector, out num);
			return (num <= (this.Radius * this.Radius));
		}

		public Boolean Intersects (ref BoundingFrustum frustum)
		{
			if (null == frustum) {
				throw new ArgumentNullException ("frustum - NullNotAllowed");
			}
			return frustum.Intersects (ref this);
		}

		public PlaneIntersectionType Intersects (ref Plane plane)
		{
			return plane.Intersects (ref this);
		}

		public <#= type #>? Intersects (ref Ray ray)
		{
			return ray.Intersects (ref this);
		}

		public Boolean Intersects (ref BoundingSphere sphere)
		{
			<#= type #> two = 2;

			<#= type #> num3;
			Vector3.DistanceSquared (ref this.Center, ref sphere.Center, out num3);
			<#= type #> radius = this.Radius;
			<#= type #> num = sphere.Radius;
			if ((((radius * radius) + ((two * radius) * num)) + (num * num)) <= num3) {
				return false;
			}
			return true;
		}

		public ContainmentType Contains (ref BoundingBox box)
		{
			Vector3 vector;
			if (!box.Intersects (ref this)) {
				return ContainmentType.Disjoint;
			}
			<#= type #> num = this.Radius * this.Radius;
			vector.X = this.Center.X - box.Min.X;
			vector.Y = this.Center.Y - box.Max.Y;
			vector.Z = this.Center.Z - box.Max.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Max.X;
			vector.Y = this.Center.Y - box.Max.Y;
			vector.Z = this.Center.Z - box.Max.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Max.X;
			vector.Y = this.Center.Y - box.Min.Y;
			vector.Z = this.Center.Z - box.Max.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Min.X;
			vector.Y = this.Center.Y - box.Min.Y;
			vector.Z = this.Center.Z - box.Max.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Min.X;
			vector.Y = this.Center.Y - box.Max.Y;
			vector.Z = this.Center.Z - box.Min.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Max.X;
			vector.Y = this.Center.Y - box.Max.Y;
			vector.Z = this.Center.Z - box.Min.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Max.X;
			vector.Y = this.Center.Y - box.Min.Y;
			vector.Z = this.Center.Z - box.Min.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			vector.X = this.Center.X - box.Min.X;
			vector.Y = this.Center.Y - box.Min.Y;
			vector.Z = this.Center.Z - box.Min.Z;
			if (vector.LengthSquared () > num) {
				return ContainmentType.Intersects;
			}
			return ContainmentType.Contains;
		}

		public ContainmentType Contains (ref BoundingFrustum frustum)
		{
			if (null == frustum) {
				throw new ArgumentNullException ("frustum - NullNotAllowed");
			}
			if (!frustum.Intersects (ref this)) {
				return ContainmentType.Disjoint;
			}
			<#= type #> num2 = this.Radius * this.Radius;
			foreach (Vector3 vector2 in frustum.cornerArray) {
				Vector3 vector;
				vector.X = vector2.X - this.Center.X;
				vector.Y = vector2.Y - this.Center.Y;
				vector.Z = vector2.Z - this.Center.Z;
				if (vector.LengthSquared () > num2) {
					return ContainmentType.Intersects;
				}
			}
			return ContainmentType.Contains;
		}

		public ContainmentType Contains (ref Vector3 point)
		{
			<#= type #> temp;
			Vector3.DistanceSquared (ref point, ref this.Center, out temp);

			if (temp >= (this.Radius * this.Radius))
			{
				return ContainmentType.Disjoint;
			}
			return ContainmentType.Contains;
		}

		public ContainmentType Contains (ref BoundingSphere sphere)
		{
			<#= type #> num3;
			Vector3.Distance (ref this.Center, ref sphere.Center, out num3);
			<#= type #> radius = this.Radius;
			<#= type #> num = sphere.Radius;
			if ((radius + num) < num3) {
				return ContainmentType.Disjoint;
			}
			if ((radius - num) < num3) {
				return ContainmentType.Intersects;
			}
			return ContainmentType.Contains;
		}

		internal void SupportMapping (ref Vector3 v, out Vector3 result)
		{
			<#= type #> num2 = v.Length ();
			<#= type #> num = this.Radius / num2;
			result.X = this.Center.X + (v.X * num);
			result.Y = this.Center.Y + (v.Y * num);
			result.Z = this.Center.Z + (v.Z * num);
		}

		public BoundingSphere Transform (Matrix44 matrix)
		{
			BoundingSphere sphere = new BoundingSphere ();
			Vector3.Transform (ref this.Center, ref matrix, out sphere.Center);
			<#= type #> num4 = ((matrix.M11 * matrix.M11) + (matrix.M12 * matrix.M12)) + (matrix.M13 * matrix.M13);
			<#= type #> num3 = ((matrix.M21 * matrix.M21) + (matrix.M22 * matrix.M22)) + (matrix.M23 * matrix.M23);
			<#= type #> num2 = ((matrix.M31 * matrix.M31) + (matrix.M32 * matrix.M32)) + (matrix.M33 * matrix.M33);
			<#= type #> num = RealMaths.Max (num4, RealMaths.Max (num3, num2));
			sphere.Radius = this.Radius * (RealMaths.Sqrt (num));
			return sphere;
		}

		public void Transform (ref Matrix44 matrix, out BoundingSphere result)
		{
			Vector3.Transform (ref this.Center, ref matrix, out result.Center);
			<#= type #> num4 = ((matrix.M11 * matrix.M11) + (matrix.M12 * matrix.M12)) + (matrix.M13 * matrix.M13);
			<#= type #> num3 = ((matrix.M21 * matrix.M21) + (matrix.M22 * matrix.M22)) + (matrix.M23 * matrix.M23);
			<#= type #> num2 = ((matrix.M31 * matrix.M31) + (matrix.M32 * matrix.M32)) + (matrix.M33 * matrix.M33);
			<#= type #> num = RealMaths.Max (num4, RealMaths.Max (num3, num2));
			result.Radius = this.Radius * (RealMaths.Sqrt (num));
		}

		public static Boolean operator == (BoundingSphere a, BoundingSphere b)
		{
			return a.Equals (b);
		}

		public static Boolean operator != (BoundingSphere a, BoundingSphere b)
		{
			if (!(a.Center != b.Center)) {
				return !(a.Radius == b.Radius);
			}
			return true;
		}
	}
